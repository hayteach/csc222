
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Week 6 â€” Pointers & References (C++)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #111827; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; }
        .skip-link { position: absolute; left: -999px; top: auto; width: 1px; height: 1px; overflow: hidden; background:#fff; color:#000; padding:8px 12px; z-index:1000 }
        .skip-link:focus { left:20px; top:20px; width:auto; height:auto; box-shadow:0 4px 12px rgba(0,0,0,0.2); }
        .container { max-width: 1000px; margin:0 auto; background:white; border-radius:15px; box-shadow:0 10px 40px rgba(0,0,0,0.2); overflow:hidden }
        header { background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color:white; padding:30px; text-align:center }
        header h1 { font-size:2em; margin-bottom:10px }
        header p { font-size:1.05em; opacity:0.95 }
        main.content { padding:40px }
        .toc { background:#f0f4ff; padding:20px; border:1px solid #a6b4e5; border-radius:8px; margin:20px 0; transition: transform .18s ease, opacity .18s ease; max-width:360px; }
        .toc.sticky { position:fixed; right:20px; top:88px; width:320px; max-width:calc(100% - 40px); z-index:1000; box-shadow:0 12px 40px rgba(0,0,0,0.08); }
        .toc.open { transform: translateY(0); }
        .toc h2 { color:#0b2b5a; font-weight:700; margin-top:0 }
        .toc a { color:#0b3b75; text-decoration:none; font-weight:700; padding:6px 8px; display:inline-block; border-radius:6px }
        .toc a:hover, .toc a:focus { color:#062343; background:#e9f0ff }
        .section { margin-bottom:40px; padding:25px; background:#f8f9fa; border-radius:10px; border-left:5px solid #667eea }
        h2 { color:#2c3e50; margin-bottom:15px; font-size:1.8em }
        h3 { color:#34495e; margin:20px 0 10px 0 }
        .code-block { background:#2c3e50; color:#ecf0f1; padding:15px; border-radius:8px; margin:10px 0; overflow-x:auto; font-family:'Courier New', monospace }
        .note { background:#fff3cd; border-left:4px solid #ffc107; padding:15px; margin:20px 0; border-radius:5px }
        #tocMenuButton { position:fixed; top:20px; right:20px; background:#667eea; color:white; border:none; border-radius:8px; padding:10px 15px; font-weight:700; display:block; opacity:0; transform:translateY(-6px); z-index:1001; box-shadow:0 6px 18px rgba(0,0,0,0.12); transition:opacity .18s ease, transform .18s ease; }
        #tocMenuButton:hover { background-color: #764ba2; transform: scale(1.05); }
        #tocMenuButton.show { opacity:1; transform:translateY(0); }
        #backToTop { position:fixed; bottom:30px; right:30px; background:#667eea; color:white; border:none; border-radius:50%; width:50px; height:50px; font-size:24px; display:flex; align-items:center; justify-content:center; opacity:0; transform:translateY(6px); z-index:999; box-shadow:0 6px 18px rgba(0,0,0,0.12); transition:opacity .18s ease, transform .18s ease; }
        #backToTop.show { opacity:1; transform:translateY(0); }
        a:focus, button:focus, input:focus, .toc a:focus { outline:3px solid #ffcc00; outline-offset:3px }
        @media (max-width:768px) { .content{padding:20px} .toc.sticky{width:calc(100vw-40px); right:10px; top:55px} #tocMenuButton { right:10px; top:10px; padding:8px 12px; font-size:12px } }
    </style>
</head>
<body>
    <a class="skip-link" href="#main-content">Skip to main content</a>
    <div class="container">
        <header>
            <h1>Week 6 â€” Pointers & References</h1>
            <p>Compact reference for pointers, references, arrays, and pointer arithmetic in C++.</p>
        </header>

        <main id="main-content" class="content" tabindex="-1" role="main">
            <nav id="toc-nav" class="toc" role="navigation" aria-label="Table of Contents">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#types">C Data Types</a></li>
                    <li><a href="#words">Words & Active Memory</a></li>
                    <li><a href="#memory-pointers">Memory Pointers</a></li>
                    <li><a href="#scalars">Pointers for Scalars</a></li>
                    <li><a href="#vectors-functions">Vectors & Functions</a></li>
                    <li><a href="#arrays">Pointers for Arrays</a></li>
                    <li><a href="#arithmetic">Pointer Arithmetic</a></li>
                    <li><a href="#takeaways">Key Takeaways</a></li>
                </ul>
            </nav>

            <section class="section" id="types" aria-labelledby="types-h">
                <h2 id="types-h">C Data Types</h2>
                <p>C and C++ provide primitive data types (int, char, float, double, bool) and derived types (arrays, pointers, references, structs, classes). The type determines size, range, and how compiler lays values out in memory.</p>
                <div class="code-block" role="region" aria-label="Data types example" tabindex="0"><pre>int i = 42;
char c = 'A';
double d = 3.14;
int arr[3] = {1,2,3};
std::vector&lt;int&gt; v = {1,2,3};</pre></div>
            </section>

            <section class="section" id="words" aria-labelledby="words-h">
                <h2 id="words-h">Words & Active Memory</h2>
                <p>"Words" refer to the machine's word size (often 4 or 8 bytes) used for alignment and addressing. Active memory is the region the program uses at runtime â€” stack (local variables) and heap (dynamic memory via new/malloc).</p>
                <p class="note"><strong>Note:</strong> Objects on the stack are destroyed when their scope ends. Heap allocations must be freed or managed with smart pointers.</p>
            </section>

            <section class="section" id="memory-pointers" aria-labelledby="mem-h">
                <h2 id="mem-h">Memory Pointers</h2>
                <p>A pointer holds a memory address that refers to storage for a value. The declaration uses * and must match the pointed type:</p>
                <div class="code-block" role="region" aria-label="Pointer basics" tabindex="0"><pre>int x = 10;
int *p = &x;   // p points to x
*p = 11;       // changes x through p
int *n = nullptr; // safe empty pointer</pre></div>
                <p class="note">Avoid dereferencing null or dangling pointers. Use smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>) for safer heap ownership.</p>
            </section>

            <section class="section" id="scalars" aria-labelledby="scalars-h">
                <h2 id="scalars-h">Pointers for Scalars</h2>
                <p>Scalars (single values) can be passed by pointer to allow modification or to avoid copying:</p>
                <div class="code-block" role="region" aria-label="Scalar pointer example" tabindex="0"><pre>void increment(int *p) {
    if(p) (*p)++;
}
int main() {
    int a = 5;
    increment(&a); // a becomes 6
}</pre></div>
            </section>

            <section class="section" id="vectors-functions" aria-labelledby="vf-h">
                <h2 id="vf-h">Pointers: Vectors & Functions</h2>
                <p>For containers like <code>std::vector</code>, prefer references (&) or const references instead of raw pointers. Pointers to functions are used for callback-style APIs.</p>
                <div class="code-block" role="region" aria-label="Vector and function pointer examples" tabindex="0"><pre>// Pass by reference (preferred)
void process(const std::vector&lt;int&gt;&amp; v) { /* read-only */ }

// Function pointer
using Callback = void(*)(int);
void register_cb(Callback cb) { /* store & call cb */ }</pre></div>
                <p class="note"><strong>Tip:</strong> Use references when you have a valid object. Use pointers when "no object" is a meaningful state (nullptr).</p>
            </section>

            <section class="section" id="arrays" aria-labelledby="arr-h">
                <h2 id="arr-h">Pointers for Arrays</h2>
                <p>Arrays decay to pointers to their first element in many contexts. Be careful with sizes & bounds â€” the pointer alone does not carry length information.</p>
                <div class="code-block" role="region" aria-label="Array pointer example" tabindex="0"><pre>int a[5] = {1,2,3,4,5};
int *p = a;         // points to a[0]
int second = *(p + 1); // pointer arithmetic to access elements

// Passing array & length
void sum(int *arr, size_t n) { /* ... */ }</pre></div>
                <p class="note">Prefer <code>std::array</code> or <code>std::vector</code> for safer length-carrying containers.</p>
            </section>

            <section class="section" id="arithmetic" aria-labelledby="arith-h">
                <h2 id="arith-h">Pointer Arithmetic</h2>
                <p>Pointer arithmetic advances in units of the pointed type size:</p>
                <div class="code-block" role="region" aria-label="Pointer arithmetic examples" tabindex="0"><pre>int arr[3] = {10,20,30};
int *p = arr;     // &arr[0]
p++;              // now points to &arr[1]
int diff = &arr[2] - &arr[0]; // 2 (difference in elements)</pre></div>
                <p class="note">Only perform pointer arithmetic within the same array/object. Going outside yields undefined behavior.</p>
            </section>

            <section class="section" id="takeaways" aria-labelledby="end-h">
                <h2 id="end-h">Key Takeaways</h2>
                <ul>
                    <li>Use references for guaranteed valid objects; use pointers when optional or nullable semantics are needed.</li>
                    <li>Prefer modern C++: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and container types to avoid manual memory errors.</li>
                    <li>Always manage lifetime and avoid dangling pointers â€” watch scope and ownership.</li>
                </ul>
            </section>

        </main>
    </div>

    <!-- TOC Menu Button -->
    <button id="tocMenuButton" title="Table of Contents" aria-controls="toc-nav" aria-expanded="false">ðŸ“‹ Menu</button>

    <!-- Back to Top Button -->
    <button id="backToTop" title="Back to Top" aria-label="Back to top">â†‘</button>

    <script>
        // Small JS to match existing week pages: TOC toggle, active-section tracking, back-to-top
        const toc = document.querySelector('.toc'); const tocLinks = document.querySelectorAll('.toc a'); const backToTopButton = document.getElementById('backToTop'); const tocMenuButton = document.getElementById('tocMenuButton'); let tocIsOpen=false;
        tocMenuButton.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); tocIsOpen=!tocIsOpen; tocMenuButton.setAttribute('aria-expanded', tocIsOpen?'true':'false'); if(tocIsOpen){ toc.classList.add('sticky','open'); tocMenuButton.textContent='âœ–ï¸ Close'; const first=toc.querySelector('a'); if(first) first.focus(); } else { toc.classList.remove('open'); tocMenuButton.textContent='ðŸ“‹ Menu'; tocMenuButton.focus(); } });
        document.addEventListener('keydown', function(e){ if(e.key==='Escape' && tocIsOpen){ toc.classList.remove('open'); tocMenuButton.textContent='ðŸ“‹ Menu'; tocMenuButton.setAttribute('aria-expanded','false'); tocIsOpen=false; tocMenuButton.focus(); } });
        document.addEventListener('click', function(event){ if(tocIsOpen && !toc.contains(event.target) && event.target !== tocMenuButton){ toc.classList.remove('open'); tocMenuButton.textContent='ðŸ“‹ Menu'; tocMenuButton.setAttribute('aria-expanded','false'); tocIsOpen=false; } });
        let ticking=false; const sections = Array.from(tocLinks).map(link=>{ const href=link.getAttribute('href'); return href ? document.querySelector(href) : null; }).filter(s=>s!==null);
        window.addEventListener('scroll', function(){ if(!ticking){ window.requestAnimationFrame(function(){ const scrollPosition=window.pageYOffset||document.documentElement.scrollTop; if(scrollPosition>200){ tocMenuButton.classList.add('show'); toc.classList.add('sticky'); } else { if(!tocIsOpen){ tocMenuButton.classList.remove('show'); toc.classList.remove('sticky'); } } if(scrollPosition>300) backToTopButton.classList.add('show'); else backToTopButton.classList.remove('show'); let currentSection=''; sections.forEach(section=>{ const sectionTop=section.offsetTop-150; const sectionBottom=sectionTop+section.offsetHeight; if(scrollPosition>=sectionTop && scrollPosition<sectionBottom) currentSection=section.getAttribute('id'); }); tocLinks.forEach(link=>{ link.classList.remove('active'); if(link.getAttribute('href')==='#'+currentSection) link.classList.add('active'); }); ticking=false; }); ticking=true; } }, { passive:true });
        backToTopButton.addEventListener('click', function(){ window.scrollTo({ top:0, behavior:'smooth' }); });
        tocLinks.forEach(link=>{ link.addEventListener('click', function(e){ e.preventDefault(); const targetId=this.getAttribute('href'); const target=document.querySelector(targetId); if(target){ window.scrollTo({ top: target.offsetTop-20, behavior:'smooth' }); if(tocIsOpen){ toc.classList.remove('open'); tocMenuButton.textContent='ðŸ“‹ Menu'; tocIsOpen=false; } } }); });
    </script>
</body>
</html>