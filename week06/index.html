
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Week 6 ‚Äî Pointers & References (C++)</title>
    <style>
 * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6; color: #111827; /* darker text for better contrast */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        /* Skip link - visible on focus */
        .skip-link {
            position: absolute;
            left: -999px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
            background: #fff;
            color: #000;
            padding: 8px 12px;
            z-index: 1000;
        }
        .skip-link:focus {
            left: 20px;
            top: 20px;
            width: auto;
            height: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* Focus outlines for keyboard users */
        a:focus, button:focus, input:focus, .check-answer-btn:focus, .toc a:focus, .code-block:focus {
            outline: 3px solid #ffcc00;
            outline-offset: 3px;
        }
        /* Make code blocks keyboard focusable */
        .code-block:focus { box-shadow: 0 0 0 4px rgba(255,193,7,0.25); }
        /* Improve contrast for focus-visible state */
        :focus-visible { outline: 3px solid #ffcc00; outline-offset: 3px; }
        .container { max-width: 1000px; margin: 0 auto; background: white; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); overflow: hidden; }
        header { background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: white; padding: 30px; text-align: center; }
        header h1 { font-size: 2em; margin-bottom: 10px; }
        header p { font-size: 1.1em; opacity: 0.9; }
        .content { padding: 40px; }
        /* Table of Contents - improved contrast for accessibility */
        .toc {
            background: #f0f4ff; /* subtle light blue for contrast */
            padding: 20px;
            border: 1px solid #a6b4e5; /* higher contrast border */
            border-radius: 8px;
            margin: 20px 0;
        }
        .toc h2 {
            margin-top: 0;
            color: #0b2b5a; /* darker, high-contrast heading */
            font-weight: 700;
            font-size: 1.1em;
        }
        .toc ul { list-style-type: none; padding-left: 0; }
        .toc li { margin: 8px 0; }
        .toc a {
            color: #0b3b75; /* darker blue for contrast */
            text-decoration: none;
            font-weight: 700;
            transition: background 0.15s ease, color 0.15s ease;
            padding: 6px 8px;
            display: inline-block;
            border-radius: 6px;
        }
        .toc a:hover, .toc a:focus {
            color: #062343;
            background: #e9f0ff; /* light highlight */
            text-decoration: none;
        }
        /* Active link styling */
        .toc a.active {
            color: #e74c3c;
            background: #fff5f5;
            box-shadow: inset 0 0 0 1px rgba(231,76,60,0.08);
            padding-left: 6px;
        }
        .section { margin-bottom: 40px; padding: 25px; background: #f8f9fa; border-radius: 10px; border-left: 5px solid #667eea; }
        /* Sticky TOC and Back to Top styles */
        #tocMenuButton {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1001;
            transition: all 0.3s ease;
            display: none;
        }
        #tocMenuButton:hover { background-color: #764ba2; transform: scale(1.05); }
        #tocMenuButton.show { display: block; }
        .toc.sticky { position: fixed; top: 60px; right: 20px; width: 280px; max-height: 70vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: none; }
        .toc.sticky.open { display: block; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-10px);} to { opacity: 1; transform: translateY(0);} }
        #backToTop { position: fixed; bottom: 30px; right: 30px; background-color: #667eea; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 24px; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: none; z-index: 999; transition: all 0.3s ease; }
        #backToTop:hover { background-color: #764ba2; transform: scale(1.1); }
        #backToTop.show { display: block; animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        h2 { color: #2c3e50; margin-bottom: 15px; font-size: 1.8em; }
        h3 { color: #34495e; margin: 20px 0 10px 0; font-size: 1.3em; }
        .code-block { background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 8px; margin: 10px 0; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.9em; }
        pre { margin: 0; white-space: pre-wrap; }
        .note { background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .quiz-section { background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 25px; margin: 30px 0; }
        .quiz-question { margin: 25px 0; padding: 20px; background: white; border-radius: 8px; }
        .quiz-question h4 { color: #2c3e50; margin-bottom: 15px; }
        .quiz-question label { display: block; padding: 10px; margin: 5px 0; background: #f8f9fa; border-radius: 5px; cursor: pointer; transition: background 0.2s; }
        .quiz-question label:hover { background: #e3f2fd; }
        .quiz-question input[type="radio"] { margin-right: 10px; }
        .check-answer-btn { background: #2196f3; color: white; border: none; padding: 10px 25px; border-radius: 6px; cursor: pointer; font-weight: 600; margin-top: 10px; transition: all 0.3s; }
        .check-answer-btn:hover { background: #1976d2; transform: translateY(-2px); }
        .feedback { margin-top: 10px; padding: 15px; border-radius: 6px; font-weight: 600; }
        .feedback.correct { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .feedback.incorrect { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .key-takeaway { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 8px; margin: 30px 0; }
        .key-takeaway ul { list-style-type: none; padding-left: 0; }
        .key-takeaway li { padding: 8px 0; padding-left: 25px; position: relative; }
        .key-takeaway li:before { content: "‚úì"; position: absolute; left: 0; font-weight: bold; font-size: 1.2em; }
        @media (max-width: 768px) { .content { padding: 20px; } }
    </style>
</head>
<body>
    <a class="skip-link" href="#main-content">Skip to main content</a>
    <div class="container">
        <header>
            <h1>Week 6 ‚Äî Pointers & References</h1>
            <p>Compact reference for pointers, references, arrays, and pointer arithmetic in C++.</p>
        </header>

        <main id="main-content" class="content" tabindex="-1" role="main">
            <nav id="toc-nav" class="toc sticky open" role="navigation" aria-label="Table of Contents">
                <h2>üìã Table of Contents</h2>
                <ul>
                    <li><a href="#types">C Data Types</a></li>
                    <li><a href="#words">Words & Active Memory</a></li>
                    <li><a href="#memory-pointers">Memory Pointers</a></li>
                    <li><a href="#scalars">Pointers for Scalars</a></li>
                    <li><a href="#vectors-functions">Vectors & Functions</a></li>
                    <li><a href="#arrays">Pointers for Arrays</a></li>
                    <li><a href="#arithmetic">Pointer Arithmetic</a></li>
                    <li><a href="#takeaways">Key Takeaways</a></li>
                </ul>
            </nav>

            <section class="section" id="types" aria-labelledby="types-h">
                <h2 id="types-h">C Data Types</h2>
                <p>C and C++ provide primitive data types (int, char, float, double, bool) and derived types (arrays, pointers, references, structs, classes). The type determines size, range, and how compiler lays values out in memory.</p>
                <div class="code-block" role="region" aria-label="Data types example" tabindex="0"><pre>int i = 42;
char c = 'A';
double d = 3.14;
int arr[3] = {1,2,3};
std::vector&lt;int&gt; v = {1,2,3};</pre></div>
            </section>

            <section class="section" id="words" aria-labelledby="words-h">
                <h2 id="words-h">Words & Active Memory</h2>
                <p>"Words" refer to the machine's word size (often 4 or 8 bytes) used for alignment and addressing. Active memory is the region the program uses at runtime ‚Äî stack (local variables) and heap (dynamic memory via new/malloc).</p>
                <p class="note"><strong>Note:</strong> Objects on the stack are destroyed when their scope ends. Heap allocations must be freed or managed with smart pointers.</p>
            </section>

            <section class="section" id="memory-pointers" aria-labelledby="mem-h">
                <h2 id="mem-h">Memory Pointers</h2>
                <p>A pointer holds a memory address that refers to storage for a value. The declaration uses * and must match the pointed type:</p>
                <div class="code-block" role="region" aria-label="Pointer basics" tabindex="0"><pre>int x = 10;
int *p = &x;   // p points to x
*p = 11;       // changes x through p
int *n = nullptr; // safe empty pointer</pre></div>
                <p class="note">Avoid dereferencing null or dangling pointers. Use smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>) for safer heap ownership.</p>
            </section>

            <section class="section" id="scalars" aria-labelledby="scalars-h">
                <h2 id="scalars-h">Pointers for Scalars</h2>
                <p>Scalars (single values) can be passed by pointer to allow modification or to avoid copying:</p>
                <div class="code-block" role="region" aria-label="Scalar pointer example" tabindex="0"><pre>void increment(int *p) {
    if(p) (*p)++;
}
int main() {
    int a = 5;
    increment(&a); // a becomes 6
}</pre></div>
            </section>

            <section class="section" id="vectors-functions" aria-labelledby="vf-h">
                <h2 id="vf-h">Pointers: Vectors & Functions</h2>
                <p>For containers like <code>std::vector</code>, prefer references (&) or const references instead of raw pointers. Pointers to functions are used for callback-style APIs.</p>
                <div class="code-block" role="region" aria-label="Vector and function pointer examples" tabindex="0"><pre>// Pass by reference (preferred)
void process(const std::vector&lt;int&gt;&amp; v) { /* read-only */ }

// Function pointer
using Callback = void(*)(int);
void register_cb(Callback cb) { /* store & call cb */ }</pre></div>
                <p class="note"><strong>Tip:</strong> Use references when you have a valid object. Use pointers when "no object" is a meaningful state (nullptr).</p>
            </section>

            <section class="section" id="arrays" aria-labelledby="arr-h">
                <h2 id="arr-h">Pointers for Arrays</h2>
                <p>Arrays decay to pointers to their first element in many contexts. Be careful with sizes & bounds ‚Äî the pointer alone does not carry length information.</p>
                <div class="code-block" role="region" aria-label="Array pointer example" tabindex="0"><pre>int a[5] = {1,2,3,4,5};
int *p = a;         // points to a[0]
int second = *(p + 1); // pointer arithmetic to access elements

// Passing array & length
void sum(int *arr, size_t n) { /* ... */ }</pre></div>
                <p class="note">Prefer <code>std::array</code> or <code>std::vector</code> for safer length-carrying containers.</p>
            </section>

            <section class="section" id="arithmetic" aria-labelledby="arith-h">
                <h2 id="arith-h">Pointer Arithmetic</h2>
                <p>Pointer arithmetic advances in units of the pointed type size:</p>
                <div class="code-block" role="region" aria-label="Pointer arithmetic examples" tabindex="0"><pre>int arr[3] = {10,20,30};
int *p = arr;     // &arr[0]
p++;              // now points to &arr[1]
int diff = &arr[2] - &arr[0]; // 2 (difference in elements)</pre></div>
                <p class="note">Only perform pointer arithmetic within the same array/object. Going outside yields undefined behavior.</p>
            </section>

            <section class="section" id="takeaways" aria-labelledby="end-h">
                <h2 id="end-h">Key Takeaways</h2>
                <ul>
                    <li>Use references for guaranteed valid objects; use pointers when optional or nullable semantics are needed.</li>
                    <li>Prefer modern C++: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and container types to avoid manual memory errors.</li>
                    <li>Always manage lifetime and avoid dangling pointers ‚Äî watch scope and ownership.</li>
                </ul>
            </section>

        </main>
    </div>

    <!-- TOC Menu Button -->
    <button id="tocMenuButton" class="show" title="Toggle Table of Contents" aria-controls="toc-nav" aria-expanded="true" aria-label="Toggle Table of Contents">‚úñÔ∏è Close</button>

    <!-- Back to Top Button -->
    <button id="backToTop" title="Back to Top" aria-label="Back to top">‚Üë</button>

<script>
    function checkAnswer(qName, correct, id) {
        const radios = document.getElementsByName(qName);
        let selected = null;
        for (const r of radios) { if (r.checked) selected = r.value; }
        const feedback = document.getElementById('feedback' + id);
        feedback.style.display = 'block';
        if (!selected) {
            feedback.textContent = 'Please select an answer.';
            feedback.className = 'feedback incorrect';
            feedback.setAttribute('tabindex','-1');
            feedback.focus();
            return;
        }
        if (selected === correct) {
            feedback.textContent = 'Correct! ‚úÖ';
            feedback.className = 'feedback correct';
            feedback.setAttribute('tabindex','-1');
            feedback.focus();
        } else {
            feedback.textContent = 'Incorrect. Try reviewing the section above. ‚ùå';
            feedback.className = 'feedback incorrect';
            feedback.setAttribute('tabindex','-1');
            feedback.focus();
        }
    }

    function checkAll() {
        const answers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b' };
        let score = 0; let total = Object.keys(answers).length;
        for (const [q, ans] of Object.entries(answers)) {
            const radios = document.getElementsByName(q);
            let selected = null; for (const r of radios) if (r.checked) selected = r.value;
            if (selected === ans) score++;
            const id = q.replace('q','');
            const feedback = document.getElementById('feedback' + id);
            feedback.style.display = 'block';
            if (!selected) { feedback.textContent = 'No answer selected.'; feedback.className='feedback incorrect'; }
            else if (selected === ans) { feedback.textContent = 'Correct! ‚úÖ'; feedback.className='feedback correct'; }
            else { feedback.textContent = 'Incorrect. ‚ùå'; feedback.className='feedback incorrect'; }
        }
        const summary = document.getElementById('quiz-summary');
        summary.textContent = `You scored ${score} / ${total}.`;
        summary.setAttribute('tabindex','-1');
        summary.focus();
    }

        // ===== Collapsible TOC Menu, Back to Top, and Active Section Highlighting =====
        const toc = document.querySelector('.toc');
        const tocLinks = document.querySelectorAll('.toc a');
        const backToTopButton = document.getElementById('backToTop');
        const tocMenuButton = document.getElementById('tocMenuButton');
        let tocIsOpen = false;

        // Get all section IDs from TOC links
        const sections = Array.from(tocLinks).map(link => {
            const href = link.getAttribute('href');
            return href ? document.querySelector(href) : null;
        }).filter(section => section !== null);

        // Toggle TOC menu
        tocMenuButton.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            tocIsOpen = !tocIsOpen;
            tocMenuButton.setAttribute('aria-expanded', tocIsOpen ? 'true' : 'false');
            if (tocIsOpen) {
                toc.classList.add('sticky', 'open');
                tocMenuButton.textContent = '‚úñÔ∏è Close';
                // move focus into TOC for keyboard users
                const firstLink = toc.querySelector('a'); if (firstLink) firstLink.focus();
            } else {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.focus();
            }
        });

        // Close menu with Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && tocIsOpen) {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.setAttribute('aria-expanded', 'false');
                tocIsOpen = false;
                tocMenuButton.focus();
            }
        });

        // Close TOC when clicking outside
        document.addEventListener('click', function(event) {
            if (tocIsOpen && !toc.contains(event.target) && event.target !== tocMenuButton) {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.setAttribute('aria-expanded', 'false');
                tocIsOpen = false;
            }
        });

        // Simple scroll handler
        let ticking = false;

        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;

                    // Show menu button after scrolling 200px
                    if (scrollPosition > 200) {
                        tocMenuButton.classList.add('show');
                        toc.classList.add('sticky');
                    } else {
                        if (!tocIsOpen) {
                            tocMenuButton.classList.remove('show');
                            toc.classList.remove('sticky');
                        }
                    }

                    // Show/hide back to top button
                    if (scrollPosition > 300) {
                        backToTopButton.classList.add('show');
                    } else {
                        backToTopButton.classList.remove('show');
                    }

                    // Highlight active section in TOC
                    let currentSection = '';
                    sections.forEach(section => {
                        const sectionTop = section.offsetTop - 150;
                        const sectionBottom = sectionTop + section.offsetHeight;

                        if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
                            currentSection = section.getAttribute('id');
                        }
                    });

                    // Update active link
                    tocLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === '#' + currentSection) {
                            link.classList.add('active');
                        }
                    });

                    ticking = false;
                });

                ticking = true;
            }
        }, { passive: true });

        // Back to top button click
        backToTopButton.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Smooth scroll for TOC links and close menu
        tocLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);

                if (targetSection) {
                    const offsetTop = targetSection.offsetTop - 20;
                    window.scrollTo({ top: offsetTop, behavior: 'smooth' });

                    // Close TOC menu after clicking a link
                    if (tocIsOpen) {
                        toc.classList.remove('open');
                        tocMenuButton.textContent = 'üìã Menu';
                        tocIsOpen = false;
                    }
                }
            });
        });

</script>
</body>
</html>