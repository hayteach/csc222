<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week ?: Template: Pointers & Destructors (C++)</title>
    <link rel="stylesheet" href="styles.css">
    <script src="script.js" defer></script>
</head>
<body>
    <a class="skip-link" href="#main-content">Skip to main content</a>
    <div class="container">
        <header>
            <h1>Week ?: Template: Pointers & Destructors</h1>
            <p>Understanding addresses, dynamic memory, and safe cleanup in C++ üîß</p>
        </header>

        <main id="main-content" class="content" tabindex="-1" role="main">
            <div class="note">
                <strong>üß† Quick note:</strong> Pointers let you work directly with memory addresses. They are powerful but require care ‚Äî especially with dynamic allocation and deallocation.
            </div>

            <nav id="toc-nav" class="toc" role="navigation" aria-label="Table of Contents">
                <h2>üìã Table of Contents</h2>
                <ul>
                    <li><a href="#pointers">What is a Pointer?</a></li>
                    <li><a href="#symbols">Symbols & Examples</a></li>
                    <li><a href="#destructors">Destructors & Memory Management</a></li>
                    <li><a href="#examples">Examples & Pitfalls</a></li>
                    <li><a href="#key-takeaways">Key Takeaways</a></li>
                    <li><a href="#additional-resources">Additional Resources</a></li>
                    <li><a href="#quiz">Quiz</a></li>
                    
                </ul>
            </nav>

            <div class="section">
                <h2 id="pointers">üìå What is a Pointer?</h2>
                <p>A pointer is a variable that stores the memory address of another value. Unlike Java or Python where references are managed for you, in C++ you explicitly create, use, and (sometimes) delete pointers.</p>

                <h3>Why care?</h3>
                <ul>
                    <li>Efficient low-level data manipulation</li>
                    <li>Dynamic memory: create objects that outlive the scope where they're created</li>
                    <li>Essential for advanced data structures (linked lists, trees) and APIs</li>
                </ul>
            </div>

            <div class="section" id="symbols">
                <h2>üî£ Pointer Symbols & Meaning</h2>
                <table class="symbols-table" aria-labelledby="symbols-caption">
                    <caption id="symbols-caption">Symbols & Common Pitfalls</caption>
                    <thead>
                        <tr>
                            <th scope="col">Symbol</th>
                            <th scope="col">Meaning / Example</th>
                            <th scope="col">Common Pitfalls</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th scope="row"><code>*</code></th>
                            <td><p>The <code>*</code> defines a variable as a pointer and is used to dereference a pointer to access or modify the value stored at that address.</p>
                                <p><strong>Declaration:</strong> <code>int* p = nullptr;</code></p>
                                <p><strong>Dereference example:</strong> <code>*p = 5;</code> ‚Äî writes the value 5 into the location pointed to by <code>p</code>.</p>
                            </td>
                            <td>Dereferencing a <code>nullptr</code> or an uninitialized pointer causes undefined behavior; always initialize and check before use.</td>
                        </tr>
                        <tr>
                            <th scope="row"><code>&amp;</code></th>
                            <td><p>The <code>&amp;</code> operator returns the address of a variable (its memory location).</p>
                                <p><strong>Example:</strong> <code>int x = 3; int* p = &amp;x;</code> ‚Äî <code>p</code> now stores the address of <code>x</code>.</p>
                            </td>
                            <td>Avoid storing the address of a variable that goes out of scope (returning address of a local) ‚Äî leads to dangling pointers.</td>
                        </tr>
                        <tr>
                            <th scope="row"><code>-&gt;</code></th>
                            <td><p>The <code>-&gt;</code> operator accesses members of an object through a pointer to that object.</p>
                                <p><strong>Example:</strong> <code>card c('s',3); card* pc = &amp;c; pc->getValue();</code></p>
                            </td>
                            <td>Using <code>-></code> on a <code>nullptr</code> or invalid object pointer causes crashes; always ensure the pointer is valid.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block" role="region" aria-label="Pointer code example" tabindex="0">
<pre>// Create a pointer
int n = 10;
int* p = &n;        // p stores the address of n
cout << "n: " << n << " | address: " << p << endl;

// Dereference
*p = 20;           // changes n through the pointer
cout << "n now: " << n << endl;

// Dynamic allocation
int* arr = new int[5]; // allocate 5 ints on the heap
arr[0] = 42;
// ...
delete[] arr;           // free heap memory when done</pre>
                </div>

                <div class="note">
                    <strong>‚ö†Ô∏è Tip:</strong> Always initialize pointers (e.g., <code>nullptr</code>) and free dynamically allocated memory with <code>delete</code> or <code>delete[]</code> when appropriate.
                </div>
            </div>

<div class="section" id="destructors">
    <h2>üßπ Destructors & Memory Management</h2>
    <p>Destructors are special member functions that run when an object is destroyed. Use them to free resources (memory, file handles) that the object acquired during its lifetime.</p>
    <div class="code-block" role="region" aria-label="Destructor code example" tabindex="0">
<pre>class Foo {
public:
    Foo() { ptr = new int[10]; }
    ~Foo() { delete[] ptr; }
private:
    int* ptr;
};

// RAII: prefer patterns where acquisition and release are tied to object lifetime.
// Better: use smart pointers
#include &lt;memory&gt;
std::unique_ptr&lt;int[]&gt; arr = std::make_unique&lt;int[]&gt;(10); // auto freed
</pre>
    </div>
    <p>Modern C++ recommends RAII and smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>) to avoid manual <code>new</code>/<code>delete</code> bookkeeping.</p>
</div>

<div class="section" id="examples">
    <h2>üîç Examples & Common Pitfalls</h2>

    <h3>Null and dangling pointers</h3>
    <div class="code-block" role="region" aria-label="Null/dangling pointers example" tabindex="0">
<pre>// Null pointer safe check
int* p = nullptr;
if (p) { *p = 5; } // check before dereferencing

// Dangling pointer example
int* q = new int(5);
delete q; // q now dangling; set to nullptr to avoid reuse
q = nullptr;
</pre>
    </div>

    <h3>Mismatched delete / delete[]</h3>
    <div class="code-block" role="region" aria-label="delete[] example" tabindex="0">
<pre>int* a = new int[5];
// wrong: delete a;  // leads to undefined behavior
delete[] a; // correct
</pre>
    </div>

    <h3>Double delete</h3>
    <p>Never call <code>delete</code> on the same pointer more than once. Reset pointers to <code>nullptr</code> after deleting, or better, use smart pointers.</p>
</div>

<div class="key-takeaway" id="key-takeaways">
    <h3>‚úÖ Key Takeaways</h3>
    <ul>
        <li>Pointers store addresses; use <code>*</code> to dereference, <code>&amp;</code> to get an address, and <code>-&gt;</code> to access members through a pointer.</li>
        <li>Always initialize pointers and check for <code>nullptr</code> before dereferencing.</li>
        <li>When you allocate with <code>new</code>, free with <code>delete</code> or <code>delete[]</code> accordingly; prefer smart pointers to avoid errors.</li>
        <li>Use destructors and RAII to ensure resources are freed reliably.</li>
    </ul>
</div>
<div class="section" id="additional-resources">
    <h2>üîó Additional Resources</h2>
    <ul>
        <li><a href="https://youtu.be/_JAoGvOPT7A" target="_blank" rel="noopener">Pointers: Crash Course</a></li>
        <li><a href="https://youtu.be/o3CaZyVxkwg" target="_blank" rel="noopener">Why we need Destructors</a></li>
        <li>Files used in the demo: <a href="https://mendocino.instructure.com/courses/21391/files/2620330?wrap=1" target="_blank" rel="noopener">pointers.zip</a></li>
    </ul>
</div>

<div class="quiz-section" id="quiz">
    <h2>üìù Quick Quiz (Check your understanding)</h2>

    <div class="quiz-question" id="q1">
        <h4>1) What does <code>int* p;</code> declare?</h4>
        <label><input type="radio" name="q1" value="a"> A variable that stores an int value</label>
        <label><input type="radio" name="q1" value="b"> A variable that stores the address of an int</label>
        <label><input type="radio" name="q1" value="c"> A function returning an int</label>
        <button class="check-answer-btn" onclick="checkAnswer('q1', 'b', 1)">Check Answer</button>
        <div class="feedback" id="feedback1" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
    </div>

    <div class="quiz-question" id="q2">
        <h4>2) Which operator gives the address of a variable?</h4>
        <label><input type="radio" name="q2" value="a"> *</label>
        <label><input type="radio" name="q2" value="b"> -&gt;</label>
        <label><input type="radio" name="q2" value="c"> &amp;</label>
        <button class="check-answer-btn" onclick="checkAnswer('q2', 'c', 2)">Check Answer</button>
        <div class="feedback" id="feedback2" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
    </div>

    <div class="quiz-question" id="q3">
        <h4>3) Which is the correct way to free an array allocated with <code>new int[5]</code>?</h4>
        <label><input type="radio" name="q3" value="a"> delete ptr;</label>
        <label><input type="radio" name="q3" value="b"> delete[] ptr;</label>
        <label><input type="radio" name="q3" value="c"> free(ptr);</label>
        <button class="check-answer-btn" onclick="checkAnswer('q3', 'b', 3)">Check Answer</button>
        <div class="feedback" id="feedback3" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
    </div>

    <div class="quiz-question" id="q4">
        <h4>4) What does a destructor do?</h4>
        <label><input type="radio" name="q4" value="a"> Initializes member variables</label>
        <label><input type="radio" name="q4" value="b"> Cleans up resources when an object is destroyed</label>
        <label><input type="radio" name="q4" value="c"> Allocates dynamic memory</label>
        <button class="check-answer-btn" onclick="checkAnswer('q4', 'b', 4)">Check Answer</button>
        <div class="feedback" id="feedback4" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
    </div>

    <div class="quiz-controls">
        <div>
            <strong>üí° Tip:</strong> Use the "Check All" button to see your total score and feedback after answering all questions!
            <br>
            <button type="button" class="check-answer-btn" onclick="checkAll({ q1: 'b', q2: 'c', q3: 'b', q4: 'b' })">Check All</button>
            <button type="button" id="clearBtn" class="check-answer-btn clear-btn" onclick="clearAnswers()" aria-label="Clear all quiz answers">Clear Answers</button>
        </div>
        <!-- Score appears directly under the controls, witty message below the score -->
        <div id="quiz-score" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
        <div id="quiz-witty" role="status" aria-live="polite" aria-atomic="true" tabindex="-1"></div>
    </div>
</div>

<div class="note">
    <strong>üí° Next steps:</strong> Try the examples in <code>pointers.zip</code>, then refactor to use <code>std::unique_ptr</code> where possible.
</div>

</main>
</div>

<!-- TOC Menu Button -->
<button id="tocMenuButton" title="Table of Contents" aria-controls="toc-nav" aria-expanded="false">üìã Menu</button>


<!-- Back to Top Button -->
<button id="backToTop" title="Back to Top" aria-label="Back to top">‚Üë</button>

<script>
        const funnyNoAnswer = [
            '‚ö†Ô∏è Whoa there! Please select an answer first!',
            '‚ö†Ô∏è Hold up! You need to pick an option before checking!',
            '‚ö†Ô∏è Don\'t be shy! Select an answer to see if you\'re right!',
            '‚ö†Ô∏è Oops! Looks like you forgot to choose an answer!',
            '‚ö†Ô∏è Hey! You gotta pick one before I can tell you if it\'s right!',
            '‚ö†Ô∏è No answer selected! Give it a go and try again!'
        ];

        const funnyCorrect = [
            '‚úÖ Nailed it! You\'re a natural!',
            '‚úÖ Boom! Correct! You\'re on fire! üî•',
            '‚úÖ Yes! You\'re crushing this!',
            '‚úÖ Perfect! Keep it up, superstar! ‚≠ê',
            '‚úÖ Correct! C++ is lucky to have you!',
            '‚úÖ Absolutely right! High five! üôå'
        ];

        const funnyIncorrect = [
            '‚ùå Oops! Not quite. Give it another shot! üí™',
            '‚ùå Close, but not cigar! Try again!',
            '‚ùå Nice try! Review the material and come back stronger!',
            '‚ùå Almost! You\'re getting warmer! üî•',
            '‚ùå Not this time, but you\'re learning! Keep going!',
            '‚ùå Swing and a miss! But that\'s okay‚Äîtry again!'
        ];

        function showFeedback(feedbackEl, type) {
            if (!feedbackEl) return;
            feedbackEl.style.display = 'block';
            let msg = '';
            if (type === 'noanswer') {
                msg = funnyNoAnswer[Math.floor(Math.random() * funnyNoAnswer.length)];
                feedbackEl.className = 'feedback incorrect';
            } else if (type === 'correct') {
                msg = funnyCorrect[Math.floor(Math.random() * funnyCorrect.length)];
                feedbackEl.className = 'feedback correct';
            } else {
                msg = funnyIncorrect[Math.floor(Math.random() * funnyIncorrect.length)];
                feedbackEl.className = 'feedback incorrect';
            }
            feedbackEl.textContent = msg;
            feedbackEl.setAttribute('tabindex', '-1');
            feedbackEl.focus();
        }

    function checkAnswer(qName, correct, id) {
        const radios = document.getElementsByName(qName);
        let selected = null;
        for (const r of radios) { if (r.checked) selected = r.value; }
        const feedback = document.getElementById('feedback' + id);
        feedback.style.display = 'block';

        if (!selected) {
            showFeedback(feedback, 'noanswer');
            return;
        }
        if (selected === correct) {
            showFeedback(feedback, 'correct');
        } else {
            showFeedback(feedback, 'incorrect');
        }
    }

    function checkAll(answers) {
        //const answers = { q1: 'b', q2: 'c', q3: 'b', q4: 'b' };
        let score = 0; let total = Object.keys(answers).length;
        try {
            for (const [q, ans] of Object.entries(answers)) {
                const radios = document.getElementsByName(q);
                let selected = null; for (const r of radios) if (r.checked) selected = r.value;
                if (selected === ans) score++;
                const id = q.replace('q','');
                const feedback = document.getElementById('feedback' + id);
                if (feedback) feedback.style.display = 'block';
                if (!selected) { showFeedback(feedback, 'noanswer'); }
                else if (selected === ans) { showFeedback(feedback, 'correct'); }
                else { showFeedback(feedback, 'incorrect'); }
            }
        } catch (err) {
            console.error('checkAll error', err);
        }

        const scoreEl = document.getElementById('quiz-score');
        const wittyEl = document.getElementById('quiz-witty');
        if (scoreEl || wittyEl) {
            try {
                const witty = (typeof getScoreMessage === 'function') ? getScoreMessage(score, total) : '';
                if (scoreEl) {
                    scoreEl.textContent = `You scored ${score} / ${total}.`;
                    scoreEl.setAttribute('tabindex','-1');
                    scoreEl.focus();
                    scoreEl.classList.add('summary-flash');
                    setTimeout(() => scoreEl.classList.remove('summary-flash'), 900);
                }
                if (wittyEl) {
                    wittyEl.textContent = witty;
                    wittyEl.setAttribute('tabindex','-1');
                }
            } catch (err) {
                console.error('Error updating score/witty', err);
            }
        } else {
            console.warn('No score/witty elements found');
        }
    }

    // Clear all answers and reset feedback/summary
    function clearAnswers() {
        // Uncheck all radio buttons inside the quiz
        const radios = document.querySelectorAll('#quiz input[type="radio"]');
        radios.forEach(r => { r.checked = false; });

        // Hide and clear all feedback elements inside the quiz
        const feedbacks = document.querySelectorAll('#quiz .feedback');
        feedbacks.forEach(f => {
            f.style.display = 'none';
            f.textContent = '';
            // Reset to base class
            f.className = 'feedback';
            f.removeAttribute('tabindex');
        });

        // Update and announce the score/message cleared
        const scoreEl = document.getElementById('quiz-score');
        const wittyEl = document.getElementById('quiz-witty');
        if (scoreEl) {
            scoreEl.textContent = 'Answers cleared.';
            scoreEl.setAttribute('tabindex', '-1');
            scoreEl.focus();
            scoreEl.classList.add('summary-flash');
            setTimeout(() => scoreEl.classList.remove('summary-flash'), 700);
        }
        if (wittyEl) {
            wittyEl.textContent = '';
            wittyEl.removeAttribute('tabindex');
        }

        // Focus the first radio input to guide keyboard users
        const firstInput = document.querySelector('#quiz input[type="radio"]');
        if (firstInput) {
            firstInput.focus();
        }
    }

    // Witty message generator for final score
    function getScoreMessage(score, total) {
        const pct = total ? Math.round((score / total) * 100) : 0;
        const perfect = ["Perfect! You're unstoppable. üéâ", "Flawless victory ‚Äî teach me your ways! üèÜ"];
        const great = ["Great job! You're almost perfect. Keep it up! üí™", "So close to perfect ‚Äî awesome work! üöÄ"];
        const solid = ["Nice work ‚Äî solid understanding. A bit more practice and you'll ace it!", "Good job! Review what you missed and try again for even more points."];
        const keepTrying = ["Keep going ‚Äî practice makes progress! üìö", "Not this time ‚Äî read the sections you missed and try again! üí°"];

        if (pct === 100) return perfect[Math.floor(Math.random() * perfect.length)];
        if (pct >= 80) return great[Math.floor(Math.random() * great.length)];
        if (pct >= 50) return solid[Math.floor(Math.random() * solid.length)];
        return keepTrying[Math.floor(Math.random() * keepTrying.length)];
    }

        // ===== Collapsible TOC Menu, Back to Top, and Active Section Highlighting =====
        const toc = document.querySelector('.toc');
        const tocLinks = document.querySelectorAll('.toc a');
        const backToTopButton = document.getElementById('backToTop');
        const tocMenuButton = document.getElementById('tocMenuButton');
        let tocIsOpen = false;

        // Get all section IDs from TOC links
        const sections = Array.from(tocLinks).map(link => {
            const href = link.getAttribute('href');
            return href ? document.querySelector(href) : null;
        }).filter(section => section !== null);

        // Toggle TOC menu
        tocMenuButton.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            tocIsOpen = !tocIsOpen;
            tocMenuButton.setAttribute('aria-expanded', tocIsOpen ? 'true' : 'false');
            if (tocIsOpen) {
                toc.classList.add('sticky', 'open');
                tocMenuButton.textContent = '‚úñÔ∏è Close';
                // move focus into TOC for keyboard users
                const firstLink = toc.querySelector('a'); if (firstLink) firstLink.focus();
            } else {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.focus();
            }
        });

        // Close menu with Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && tocIsOpen) {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.setAttribute('aria-expanded', 'false');
                tocIsOpen = false;
                tocMenuButton.focus();
            }
        });

        // Close TOC when clicking outside
        document.addEventListener('click', function(event) {
            if (tocIsOpen && !toc.contains(event.target) && event.target !== tocMenuButton) {
                toc.classList.remove('open');
                tocMenuButton.textContent = 'üìã Menu';
                tocMenuButton.setAttribute('aria-expanded', 'false');
                tocIsOpen = false;
            }
        });

        // Simple scroll handler
        let ticking = false;

        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;

                    // Show menu button after scrolling 200px
                    if (scrollPosition > 200) {
                        tocMenuButton.classList.add('show');
                        toc.classList.add('sticky');
                    } else {
                        if (!tocIsOpen) {
                            tocMenuButton.classList.remove('show');
                            toc.classList.remove('sticky');
                        }
                    }

                    // Show/hide back to top button
                    if (scrollPosition > 300) {
                        backToTopButton.classList.add('show');
                    } else {
                        backToTopButton.classList.remove('show');
                    }

                    // Highlight active section in TOC
                    let currentSection = '';
                    sections.forEach(section => {
                        const sectionTop = section.offsetTop - 150;
                        const sectionBottom = sectionTop + section.offsetHeight;

                        if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
                            currentSection = section.getAttribute('id');
                        }
                    });

                    // Update active link
                    tocLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === '#' + currentSection) {
                            link.classList.add('active');
                        }
                    });

                    ticking = false;
                });

                ticking = true;
            }
        }, { passive: true });

        // Back to top button click
        backToTopButton.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Smooth scroll for TOC links and close menu
        tocLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);

                if (targetSection) {
                    const offsetTop = targetSection.offsetTop - 20;
                    window.scrollTo({ top: offsetTop, behavior: 'smooth' });

                    // Close TOC menu after clicking a link
                    if (tocIsOpen) {
                        toc.classList.remove('open');
                        tocMenuButton.textContent = 'üìã Menu';
                        tocIsOpen = false;
                    }
                }
            });
        });

</script>

</body>
</html>