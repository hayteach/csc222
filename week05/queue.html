<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ðŸ”„ Week 05 â€” Queues</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <a href="#main-content" class="skip-to-main">Skip to main content</a>

    <button id="menuBtn" aria-label="Toggle table of contents" aria-expanded="false">
        <span class="emoji" aria-hidden="true">ðŸ“‘</span> Menu
    </button>

    <nav id="tableOfContents" role="navigation" aria-label="Table of contents">
        <h3>Contents</h3>
        <ul>
            <li><a href="#overview">Overview</a></li>
            <li><a href="#definition">Definition of a Queue</a></li>
            <li><a href="#operations">Queue Operations</a></li>
            <li><a href="#implementation">Array-based Implementation</a></li>
            <li><a href="#circular">Circular Queue</a></li>
            <li><a href="#linked">Linked-list Implementation</a></li>
            <li><a href="#comparison">Queue vs. Stack</a></li>
            <li><a href="#testers">Testers</a></li>
            <li><a href="#references">References</a></li>
        </ul>
    </nav>

    <div class="container">
        <header role="banner">
            <h1><span class="emoji" aria-hidden="true">ðŸ”„</span> Week 05 â€” Queues</h1>
            <p>Understanding the Queue Abstract Data Type (ADT) and its implementations</p>
        </header>

        <main id="main-content" role="main" tabindex="-1">
            <section id="overview" aria-labelledby="overview-heading">
                <h2 id="overview-heading">Overview</h2>
                <p>A queue is another abstract data type that simulates a very common occurrence in nature. Think of it as a line where people wait for service. The key principle is FIFO (First In, First Out): the first item added is the first one removed. This is different from a stack, which is LIFO (Last In, First Out).</p>
                <p>Queues are used in many real-world applications, such as:</p>
                <ul>
                    <li>Print queues in operating systems</li>
                    <li>Customer service lines</li>
                    <li>Task scheduling in computers</li>
                    <li>Breadth-first search algorithms</li>
                </ul>
                <p>Review all sections below to understand how queues work and how to implement them.</p>
            </section>

            <section id="definition" aria-labelledby="definition-heading">
                <h2 id="definition-heading">Definition of a Queue</h2>
                <p>In the real world, we have occasions when we accumulate stuff into a holding area for later use. Each of these areas can have different properties. A Queue ADT acts just like a line at the DMV or a Bank. If you think about how these lines work, the first thing you can get at is the first thing you added to the queue. So a queue is known as a FIFO (First In - First Out) structure.&nbsp;</p>
                <p>First person in line is the first person to get service!</p>
                <figure>
                    <img src="../assets/image_queue.jpg" alt="People waiting in line as an analogy for a queue" width="320" height="181">
                    <figcaption>Analogy: People in a line â€” the first to arrive is served first.</figcaption>
                </figure>
                <p>This FIFO behavior is crucial for fairness in many systems. Unlike stacks, queues do not allow access to the middle elements directly.</p>
            </section>

            <section id="operations" aria-labelledby="operations-heading">
                <h2 id="operations-heading">Queue Operations</h2>
                <p>Just like for the Stack ADT, we want to create a Queue interface so that all queues, regardless of how we implement them, will have and use a common set of methods. In essence, from a user standpoint, it won't matter whether we implement the queue using an array or a linked-list. Their program will work with either since all of the methods are named the same and produce identical output.</p>
                <p>This is, by the way, one of the primary reasons to use interfaces for common ADTs.</p>
                <p>The queue ADT provides the following operations:</p>
                <ul>
                    <li><strong>initializeQueue()</strong>: Sets up an empty queue.</li>
                    <li><strong>isEmptyQueue()</strong>: Checks if the queue has no elements.</li>
                    <li><strong>isFullQueue()</strong>: Checks if the queue is at maximum capacity.</li>
                    <li><strong>front()</strong>: Returns the element at the front without removing it.</li>
                    <li><strong>rear()</strong>: Returns the element at the rear without removing it.</li>
                    <li><strong>addQueue(ItemType)</strong>: Adds an item to the rear of the queue.</li>
                    <li><strong>deleteQueue()</strong>: Removes the front element from the queue.</li>
                </ul>
                <figure>
                    <img src="../assets/queueADT_h.jpg" alt="Picture of the queueADT.h file showing the interface" />
                    <figcaption>Queue ADT interface â€” pure virtual methods.</figcaption>
                </figure>
                <p>The implementation of the queueADT interface is shown in the figure below. Please note that all of the methods we defined in this ADT are virtual and abstract. Because of this, there can be no corresponding implementation file hence there is no include statement for queueADT.cpp because that file will not exist. The actual implementation details will be coded in any class that implements this interface.</p>
                <figure>
                    <img src="../assets/queueADT_h_file.jpg" alt="queueADT_h_file.jpg" />
                    <figcaption>queueADT.h â€” Abstract base class for queues.</figcaption>
                </figure>
                <p>Here's a copy of the actual code file: <a href="files/queueADT.h">queueADT.h</a></p>
            </section>

            <section id="implementation" aria-labelledby="implementation-heading">
                <h2 id="implementation-heading">Array-based Implementation</h2>
                <p>Now that we've defined how a queue works, we can look at creating one that we can use in other programs to solve problems. The first implementation we will look at is that of using an Array to store the elements we put into our queue. First, we will look at the UML diagram for an array-based queue that implements all of the queue operations from the queueADT interface plus the additional attributes and methods we need as described below.</p>
                <p>In addition to the interface methods of:</p>
                <ul>
                    <li>initializeQueue()</li>
                    <li>isEmptyQueue()</li>
                    <li>isFullQueue()</li>
                    <li>front()</li>
                    <li>rear()</li>
                    <li>addQueue(const ItemType&amp;)</li>
                    <li>deleteQueue()</li>
                </ul>
                <p>We need the following attributes to use an array:</p>
                <ul>
                    <li><strong>maxQueueSize</strong>: Defines how big our array is (the maximum number of ItemType things we can store in the queue).</li>
                    <li><strong>count</strong>: The current size of the Queue (how many things are currently in the queue).</li>
                    <li><strong>queueFront</strong>: The current front of the queue (necessary when you want to take things out of the queue).</li>
                    <li><strong>queueRear</strong>: The current rear of the queue (necessary when you want to add things to the queue).</li>
                    <li><strong>*list</strong>: Pointer to our array of ItemType things.</li>
                </ul>
                <p>We also have the added methods so that we can construct arrayQueue objects:</p>
                <ul>
                    <li><strong>arrayQueue(int = 100)</strong>: Default arrayQueue constructor.</li>
                    <li><strong>arrayQueue(arrayQueue)</strong>: Constructor for creating a queue from an existing queue.</li>
                    <li><strong>~arrayQueue()</strong>: Destructor for the arrayQueue object.</li>
                    <li><strong>operator=</strong>: Defines what the assignment operator (=) will do when using arrayQueue objects.</li>
                </ul>
                <figure>
                    <img src="../assets/arrayQueue_UML.jpg" alt="UML diagram for the array-based queue implementation" />
                    <figcaption>UML diagram for the array-based queue implementation.</figcaption>
                </figure>
                <p>I've included a copy of my files for this class. We will not have time to go over each method in detail so you should review the code, test it to make sure it works and reach out to me if you have any questions on any of the methods.</p>
                <p><a href="files/arrayQueue.h" alt="Header file for array-based queue implementation">arrayQueue.h</a></p>
                <p><a href="files/arrayQueue.cpp" alt="Implementation file for array-based queue">arrayQueue.cpp</a></p>
                <p>Note: Array-based queues can become inefficient if the array wraps around (circular queue implementation is often used to optimize this).</p>
            </section>

            <section id="circular" aria-labelledby="circular-heading">
                <h2 id="circular-heading">Circular Queue</h2>
                <p>To address the inefficiency of shifting elements in a linear array queue, we use a circular queue. In a circular queue, the front and rear wrap around to the beginning of the array when they reach the end. This allows for better space utilization.</p>
                <p>Key points:</p>
                <ul>
                    <li>Uses modulo arithmetic for indices: <code>rear = (rear + 1) % maxSize</code></li>
                    <li>Full condition: <code>(rear + 1) % maxSize == front</code></li>
                    <li>Empty condition: <code>front == rear</code></li>
                </ul>
                <figure>
                    <img src="../assets/circular_queue.png" alt="Diagram of a circular queue" /><img src="../assets/cq2.jpeg" width="400" alt="Diagram showing wrap-around in a circular queue" />
                    <br><figcaption>Circular queue visualization â€” front and rear can wrap around.</figcaption>
                </figure>
                <p>Circular queues prevent wasted space and are essential for efficient queue implementations.</p>
            </section>

            <section id="linked" aria-labelledby="linked-heading">
                <h2 id="linked-heading">Linked-list Implementation</h2>
                <p>Queues can also be implemented using linked lists, which offer dynamic sizing and avoid the fixed-size limitation of arrays.</p>
                <p>In a linked-list queue:</p>
                <ul>
                    <li>Each node contains data and a pointer to the next node.</li>
                    <li><strong>Front</strong> points to the first node (for dequeue).</li>
                    <li><strong>Rear</strong> points to the last node (for enqueue).</li>
                    <li>Enqueue: Add a new node at the rear and update rear pointer.</li>
                    <li>Dequeue: Remove the front node and update front pointer.</li>
                </ul>
                <figure>
                    <img src="../assets/linked_queue.jpg" alt="Linked-list queue structure" />
                    <figcaption>Linked-list queue â€” nodes linked together.</figcaption>
                </figure>
                <p>Advantages: No size limit, efficient insertions/deletions. Disadvantages: Extra memory for pointers.</p>
                <p>Example code files: <a href="files/linkedQueue.h">linkedQueue.h</a> and <a href="files/linkedQueue.cpp">linkedQueue.cpp</a></p>
            </section>

            <section id="comparison" aria-labelledby="comparison-heading">
                <h2 id="comparison-heading">Queue vs. Stack</h2>
                <p>Queues and stacks are both linear data structures but differ in their access patterns:</p>
                <table class="comparison-table" border="1">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Queue (FIFO)</th>
                            <th>Stack (LIFO)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>Insertion</td><td>Rear (enqueue)</td><td>Top (push)</td></tr>
                        <tr><td>Deletion</td><td>Front (dequeue)</td><td>Top (pop)</td></tr>
                        <tr><td>Access</td><td>Front and rear</td><td>Only top</td></tr>
                        <tr><td>Real-world analogy</td><td>Line at a store</td><td>Stack of plates</td></tr>
                        <tr><td>Applications</td><td>BFS, job scheduling</td><td>Function calls, undo operations</td></tr>
                    </tbody>
                </table>
                <p>Understanding these differences helps in choosing the right data structure for the problem.</p>
            </section>

            <section id="testers" aria-labelledby="testers-heading">
                <h2 id="testers-heading">Testers</h2>
                <p>Once we've coded our queues made from arrays, we need to test them. The following program creates queues, adds things on, deletes them off, etc...</p>
                <p><a href="files/testProgQueueArray.cpp" alt="Implementation file for the test program">testProgQueueArray.cpp</a></p>
                <p>Testing is crucial to ensure your implementation handles edge cases like empty queues, full queues, and wrap-around scenarios.</p>
            </section>

            <section id="references" aria-labelledby="references-heading">
                <h3 id="references-heading">References</h3>
                <p><em>Ref: Malik (2018). C++ Programming: Program Design Including Data Structures, 5th Ed (ch. 18). ISBN-13: 978-1-337-11756-2</em></p>
            </section>
        </main>
    </div>

    <button id="backToTop" aria-label="Back to top">â†‘</button>
    <script src="../scripts.js" defer></script>
</body>
</html>